"""Generate aspiration/preference regression figure (Fig 4).

Source: 04_aspiration_preference_regressions/03_aspiration_preferences_dankatfork.ipynb

Produces:
  - reproducibility/fig4.pdf     (main figure, 6 panels A–F)
  - reproducibility/si_fig1.pdf  (SI: full regression figure — generated by si_fig1.py)

Data assembly (all from public_data/ + derived/):
  - respondents.csv               → user metadata, prestige bins, aspiration venues
  - field_consensus_rankings.csv  → field-normed venue ranks
  - individual_rankings.csv       → each user's top-ranked preference venue

Notes:
  - Gender encoding: gm→0 (men), gf→1 (women), -→NaN (excluded)
  - Career filter: Assistant / Associate / Full Professor only
  - Additional filters: venue_bug==False, gender.notna()
  - Prestige is inverted (11 - bin) so x-axis reads "increasing prestige →"
  - Gender forest-plot coefficients are negated to show men − women

Usage:
  .venv/bin/python reproducibility/fig4.py

Run compute_rankings.py first if derived/ files are missing.
"""

import re
import sys
from pathlib import Path

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib.lines import Line2D
from matplotlib.patches import ConnectionPatch
from matplotlib.transforms import blended_transform_factory
from scipy import stats
from statsmodels.formula.api import ols

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
HERE = Path(__file__).parent
PUBLIC = HERE.parent / "public_data"
DERIVED = HERE / "derived"

_required = [
    DERIVED / "individual_rankings.csv",
    DERIVED / "field_consensus_rankings.csv",
]
_missing = [p for p in _required if not p.exists()]
if _missing:
    print("Missing required derived files:")
    for p in _missing:
        print(f"  {p}")
    print("\nPlease run first:\n  .venv/bin/python reproducibility/compute_rankings.py")
    sys.exit(1)

# ---------------------------------------------------------------------------
# Colors (from 03_aspiration_preferences_dankatfork.ipynb)
# ---------------------------------------------------------------------------
C_LIGHT = np.array([107, 171, 250]) / 255   # light blue (aspirations)
C_DARK  = C_LIGHT * 0.55                     # dark blue  (preferences)

# For SI figure (uses the original custom_plotting colors)
myblue   = "#1F3C88"
myyellow = "#E4B700"

# ---------------------------------------------------------------------------
# Load and assemble data
# ---------------------------------------------------------------------------
respondents = pd.read_csv(PUBLIC / "respondents.csv")
field_cons  = pd.read_csv(DERIVED / "field_consensus_rankings.csv")
indiv       = pd.read_csv(DERIVED / "individual_rankings.csv")

# Field-normed score: 0=lowest, 1=highest within each field's consensus
field_cons["normed"] = field_cons.groupby("field")["score"].transform(
    lambda x: (x - x.min()) / (x.max() - x.min())
)
field_normed_lookup = field_cons.set_index(["field", "venue_db_id"])["normed"]

def lookup_field_normed(field_series, venue_series):
    keys = list(zip(field_series, venue_series))
    return pd.Series(
        [field_normed_lookup.get(k, np.nan) for k in keys],
        index=field_series.index,
    )

# Top-ranked preference venue per user (ordinal_rank == 0 → best)
top_venue = (
    indiv[indiv["ordinal_rank"] == 0]
    .set_index("user_db_id")["venue_db_id"]
    .rename("top_ranked_venue_id")
)

# Assemble working dataframe
df = respondents.copy()
df["gender"] = df["gender"].map({"gm": 0.0, "gf": 1.0})

PROFESSOR_STAGES = {"Assistant Professor", "Associate Professor", "Full Professor"}
df = df[df["career_stage"].isin(PROFESSOR_STAGES)].copy()

df["top_init_field_normed"] = lookup_field_normed(df["field"], df["top_init_venue_db_id"])
df = df.join(top_venue, on="user_db_id")
df["top_ranked_venue_field_normed"] = lookup_field_normed(df["field"], df["top_ranked_venue_id"])

df = df[
    (df["venue_bug"] == False) &
    (df["gender"].notna()) &
    (df["academia_prestige_bin_10"].notna())
].copy()

career_dummies = pd.get_dummies(df["career_stage"])[["Associate Professor", "Full Professor"]]
career_dummies.columns = ["associate_prof_dummy", "full_prof_dummy"]
df = df.join(career_dummies)

# Inverted prestige bin: 10=most prestigious, 1=least prestigious
df["academia_prestige_bin_10_inv"] = 11 - df["academia_prestige_bin_10"]

outcome = "field_normed"

# ---------------------------------------------------------------------------
# Regression helper
# ---------------------------------------------------------------------------
def run_one_regression(data, venue_type, outcome_type, level_type, prestige_level):
    model = ols(
        f"{venue_type}_{outcome_type} ~ associate_prof_dummy + full_prof_dummy"
        f" + {prestige_level} + gender",
        data=data,
    ).fit()
    coefficients = model.params[1:]
    p_values     = model.pvalues[1:]
    conf_int     = model.conf_int()[1:]
    conf_int.columns = ["ci_lower", "ci_upper"]
    results = coefficients.to_frame(name="coefficient")
    results["p-value"]              = p_values
    results[["ci_lower", "ci_upper"]] = conf_int
    results["n"]     = model.nobs
    results["model"] = f"{level_type}_{venue_type}_{outcome_type}"
    results.index    = ["Associate", "Full", "Prestige", "Gender"]
    return results

# ---------------------------------------------------------------------------
# Compute regression results
# ---------------------------------------------------------------------------
res = pd.DataFrame()
for venue in ("top_init", "top_ranked_venue"):
    add = run_one_regression(df, venue, outcome, "Academia", "academia_prestige_bin_10_inv")
    res = pd.concat([res, add])
    for field in sorted(df["field"].unique()):
        subset = df[df["field"] == field]
        add = run_one_regression(subset, venue, outcome, field, "academia_prestige_bin_10_inv")
        res = pd.concat([res, add])

# ---------------------------------------------------------------------------
# Scatter data for panels A and B
# ---------------------------------------------------------------------------
prestige = (
    df.groupby("academia_prestige_bin_10_inv")[
        [f"top_init_{outcome}", f"top_ranked_venue_{outcome}"]
    ]
    .agg(["mean", "sem", "count"])
    .reset_index(drop=True)
)
prestige.index += 1

gender = df.groupby("gender")[
    [f"top_init_{outcome}", f"top_ranked_venue_{outcome}"]
].agg(["mean", "sem", "count"]).reset_index(drop=True)

# Significance of men vs women (z-test using SEM)
def z_test_stars(mean1, sem1, mean2, sem2):
    z = (mean1 - mean2) / np.sqrt(sem1**2 + sem2**2)
    p = 2 * (1 - stats.norm.cdf(abs(z)))
    if p < 0.001:   return "***"
    elif p < 0.01:  return "**"
    elif p < 0.05:  return "*"
    else:           return "n.s."

stars_pref = z_test_stars(
    gender.loc[0, (f"top_ranked_venue_{outcome}", "mean")],
    gender.loc[0, (f"top_ranked_venue_{outcome}", "sem")],
    gender.loc[1, (f"top_ranked_venue_{outcome}", "mean")],
    gender.loc[1, (f"top_ranked_venue_{outcome}", "sem")],
)
stars_asp = z_test_stars(
    gender.loc[0, (f"top_init_{outcome}", "mean")],
    gender.loc[0, (f"top_init_{outcome}", "sem")],
    gender.loc[1, (f"top_init_{outcome}", "mean")],
    gender.loc[1, (f"top_init_{outcome}", "sem")],
)

# ---------------------------------------------------------------------------
# Forest plot configuration
# ---------------------------------------------------------------------------
# "All Resp." in plot_order causes "Academia" (from model names) to sort as NaN
# → placed at the end → highest y position (top of plot). Intentional.
plot_order = [
    "All Resp.", "Biology", "Business", "Chemistry", "Computer science",
    "Economics", "Engineering", "History", "Mathematics", "Medicine",
    "Philosophy", "Physics", "Psychology", "Sociology",
][::-1]

names_abbrev = {
    "Academia":        "All Resp.",
    "Biology":         "Biology",
    "Business":        "Business",
    "Chemistry":       "Chemistry",
    "Computer science":"Comp. Sci.",
    "Economics":       "Economics",
    "Engineering":     "Engineering",
    "History":         "History",
    "Mathematics":     "Math",
    "Medicine":        "Medicine",
    "Philosophy":      "Philosophy",
    "Physics":         "Physics",
    "Psychology":      "Psychology",
    "Sociology":       "Sociology",
}

xlim_prestige = (-0.05, 0.05)
xlim_gender   = (-0.27, 0.27)

# ---------------------------------------------------------------------------
# Build figure
# ---------------------------------------------------------------------------
plt.rcParams["font.size"]       = 12
plt.rcParams["font.family"]     = "Arial"
plt.rcParams["axes.labelsize"]  = 12
plt.rcParams["xtick.labelsize"] = 12
plt.rcParams["ytick.labelsize"] = 12
label_fontsize = 12
ms = 8
ls = "--"

fig = plt.figure(figsize=(13, 7))
gs  = gridspec.GridSpec(2, 1, height_ratios=[1, 1.3], hspace=0.35)
gs_top    = gridspec.GridSpecFromSubplotSpec(1, 2, subplot_spec=gs[0],
                                             width_ratios=[2, 1.3], wspace=0.3)
gs_bottom = gridspec.GridSpecFromSubplotSpec(1, 4, subplot_spec=gs[1], wspace=0.3)

ax_A  = fig.add_subplot(gs_top[0, 0])
ax_B  = fig.add_subplot(gs_top[0, 1])
axes_bottom = [fig.add_subplot(gs_bottom[0, i]) for i in range(4)]

# ---------------------------------------------------------------------------
# Panel A: prestige scatter
# ---------------------------------------------------------------------------
x1, y1, yerr1 = prestige.index, prestige[f"top_init_{outcome}"]["mean"],         prestige[f"top_init_{outcome}"]["sem"]
x2, y2, yerr2 = prestige.index, prestige[f"top_ranked_venue_{outcome}"]["mean"],  prestige[f"top_ranked_venue_{outcome}"]["sem"]

ax_A.errorbar(x1, y1, yerr1, ls=ls, marker="o", markersize=ms, markeredgecolor="k", color=C_LIGHT)
ax_A.errorbar(x2, y2, yerr2, ls=ls, marker="o", markersize=ms, markeredgecolor="k", color=C_DARK)
ax_A.text(0.97, 0.02, "increasing prestige →",
          transform=ax_A.transAxes, ha="right", va="bottom", fontsize=label_fontsize)
ax_A.text(1.1, y1.iloc[2] + 0.02, "Top aspirations",
          ha="left", va="bottom", color=C_LIGHT, fontsize=label_fontsize)
ax_A.text(1.1, y2.iloc[2] + 0.02, "Top preferences",
          ha="left", va="bottom", color=C_DARK, fontsize=label_fontsize)
ax_A.set_xticks(x1)
ax_A.set_ylim([0.55, 0.9])
ax_A.set_xlabel("Prestige decile")
ax_A.set_ylabel("Field rank of\nselected venue")

# ---------------------------------------------------------------------------
# Panel B: gender scatter with significance brackets
# ---------------------------------------------------------------------------
men_pref  = gender.loc[0, (f"top_ranked_venue_{outcome}", "mean")]
women_pref = gender.loc[1, (f"top_ranked_venue_{outcome}", "mean")]
men_asp   = gender.loc[0, (f"top_init_{outcome}", "mean")]
women_asp  = gender.loc[1, (f"top_init_{outcome}", "mean")]
men_pref_err   = gender.loc[0, (f"top_ranked_venue_{outcome}", "sem")]
women_pref_err = gender.loc[1, (f"top_ranked_venue_{outcome}", "sem")]
men_asp_err    = gender.loc[0, (f"top_init_{outcome}", "sem")]
women_asp_err  = gender.loc[1, (f"top_init_{outcome}", "sem")]

y_b    = np.array([men_pref, women_pref, men_asp, women_asp])
yerr_b = np.array([men_pref_err, women_pref_err, men_asp_err, women_asp_err])
colors_b  = [C_DARK, C_DARK, C_LIGHT, C_LIGHT]
markers_b = ["s", "v", "s", "v"]
labs_b    = ["Men", "Women", "Men", "Women"]
x_b = np.arange(len(y_b))

for i in range(len(x_b)):
    ax_B.errorbar(x_b[i], y_b[i], yerr=yerr_b[i],
                  marker=markers_b[i], markersize=ms,
                  color=colors_b[i], markeredgecolor="k")
    ax_B.text(x_b[i], y_b[i] - 0.02, labs_b[i],
              ha="center", va="top", fontsize=label_fontsize)

yl = ax_A.get_ylim()
y_bar = yl[1] - 0.03
for x_lo, x_hi, stars in [(0, 1, stars_pref), (2, 3, stars_asp)]:
    ax_B.plot([x_lo, x_hi], [y_bar, y_bar], "k-", linewidth=1)
    ax_B.plot([x_lo, x_lo], [y_bar - 0.01, y_bar], "k-", linewidth=1)
    ax_B.plot([x_hi, x_hi], [y_bar - 0.01, y_bar], "k-", linewidth=1)
    ax_B.text((x_lo + x_hi) / 2, y_bar + 0.005, stars,
              ha="center", va="bottom", fontsize=12)

ax_B.set_xlim([-0.5, 3.5])
ax_B.set_xticks([0.5, 2.5])
ax_B.set_xticklabels(["Top preferences", "Top aspirations"])
ax_B.set_ylim(yl)
ax_B.set_ylabel("Field rank of\nselected venue")

# ---------------------------------------------------------------------------
# Panels C–F: forest plots
# ---------------------------------------------------------------------------
whitespace = []

for a, rank_index in enumerate(["Prestige", "Gender"]):
    for b, venue_type in enumerate([f"top_ranked_venue_{outcome}", f"top_init_{outcome}"]):
        i = 2 * a + b
        ax = axes_bottom[i]

        to_plot = res[
            res["model"].str.contains(venue_type.replace(f"_{outcome}", "")) &
            (res.index == rank_index)
        ].copy()
        to_plot["name_to_plot"] = to_plot["model"].str.replace(
            rf"_{venue_type}", "", regex=True
        )
        to_plot["sort"] = pd.Categorical(
            to_plot["name_to_plot"], categories=plot_order, ordered=True
        )
        to_plot = to_plot.sort_values("sort")

        # Negate gender coefficients to show men − women
        if rank_index == "Gender":
            to_plot["coefficient"] = -to_plot["coefficient"]
            to_plot["ci_lower"], to_plot["ci_upper"] = (
                -to_plot["ci_upper"].copy(),
                -to_plot["ci_lower"].copy(),
            )

        color = C_DARK if "top_ranked_venue" in venue_type else C_LIGHT
        colors     = ["white" if p > 0.05 else color for p in to_plot["p-value"]]
        edgecolors = ["grey"  if p > 0.05 else color for p in to_plot["p-value"]]

        ypos = 0
        for j in range(len(to_plot)):
            name = to_plot["name_to_plot"].iloc[j]
            edge = "k" if name == "All Resp." else edgecolors[j]
            sz   = ms ** 2 if name == "All Resp." else plt.rcParams["lines.markersize"] ** 2
            ax.scatter(to_plot["coefficient"].iloc[j], ypos,
                       marker="o", facecolors=colors[j], edgecolors=edge, s=sz, zorder=2)
            ax.hlines(ypos, to_plot["ci_lower"].iloc[j], to_plot["ci_upper"].iloc[j],
                      color=edgecolors[j], zorder=0)
            ypos += 1
            if "Biology" in name:
                if i == 0:           # record gap position only once
                    whitespace.append(ypos)
                ypos += 1

        ax.axvline(x=0, color="black", linewidth=1.5, zorder=0)
        ax.set_yticks([])
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)
        ax.set_xlim(xlim_prestige if rank_index == "Prestige" else xlim_gender)
        ax.grid(axis="x", alpha=0.5)

# y-axis labels (field names + N) on the left of panel C only
num_people = to_plot["n"].astype(int).tolist()
ax_labels  = [re.sub(rf"_{venue_type}", "", name) for name in to_plot["model"]]

pad = -0.4
ypos_label = 0
for num, label in zip(num_people, ax_labels):
    kw = {"weight": "bold"} if "Academia" in label else {}
    n_str = f"N={num}" if "Academia" in label else str(num)
    axes_bottom[0].text(
        -0.05, ypos_label, n_str,
        transform=blended_transform_factory(axes_bottom[0].transAxes, axes_bottom[0].transData),
        fontsize=label_fontsize, ha="right", va="center", **kw,
    )
    axes_bottom[0].text(
        pad, ypos_label, names_abbrev[label],
        transform=blended_transform_factory(axes_bottom[0].transAxes, axes_bottom[0].transData),
        fontsize=label_fontsize, ha="right", va="center", **kw,
    )
    ypos_label += 1
    if "Biology" in label:
        ypos_label += 1

# x-axis labels
axes_bottom[0].set_xlabel("Top preference rank\nper prestige decile",  fontsize=label_fontsize)
axes_bottom[1].set_xlabel("Top aspiration rank\nper prestige decile",   fontsize=label_fontsize)
axes_bottom[2].set_xlabel("Top preference rank diff.\nmen - women",     fontsize=label_fontsize)
axes_bottom[3].set_xlabel("Top aspiration rank diff.\nmen - women",     fontsize=label_fontsize)

# x-axis ticks
axes_bottom[0].set_xticks(np.arange(-0.04, 0.041, 0.02))
axes_bottom[1].set_xticks(np.arange(-0.04, 0.041, 0.02))
axes_bottom[2].set_xticks(np.arange(-0.2, 0.21, 0.1))
axes_bottom[3].set_xticks(np.arange(-0.2, 0.21, 0.1))

# Panel labels
for idx, ax in enumerate(axes_bottom):
    ax.text(0.01, 1.0, "CDEF"[idx],
            transform=ax.transAxes, fontsize=16, ha="left", va="top", weight="bold")
ax_A.text(-0.15, 1.03, "A", transform=ax_A.transAxes,
          fontsize=16, ha="left", va="top", weight="bold")
ax_B.text(-0.3,  1.03, "B", transform=ax_B.transAxes,
          fontsize=16, ha="left", va="top", weight="bold")

sns.despine()
# Remove left spine from panels D, E, F (must follow sns.despine which restores it)
for ax in axes_bottom[1:]:
    ax.spines["left"].set_visible(False)

out = HERE / "fig4.pdf"
plt.savefig(out, bbox_inches="tight")
print(f"Saved: {out}")
# SI figure is generated by si_fig1.py
